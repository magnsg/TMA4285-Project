---
title: "Time Series Project"
author: "Emma E Botten, Magnus S Grytten and Erling F Steen"
date: "2022-11-19"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(R.matlab)
library(depmixS4)
library(ggplot2)
library(plot.matrix)
```

## Read the cell data

```{r}
data <- readMat("Mouse28-140313_BS0150_HMMready.mat")
angdata <- as.vector(data$resampledAwakeHeadAngleData)
# Transpose thet data so that there are 71 columns, one column for each cell, and 15243 rows, one for each time interval.
celldata <- t(data$celldata)
```

### Exclude cells that are less active than 100 times

```{r}
# Exclude cells that are active less than 100 times overall 
col_idx = which(colSums(celldata)<100)
celldata = celldata[,-col_idx]
```

```{r}
cell_data <- data.frame(celldata)
# Response and list must be on list-form
# Response has to be in a list
res <- list()
# List of families. One for each cell
families <- list()
# Number of columns(cells)
n_cells <- ncol(cell_data)
for (i in 1:n_cells) {
  form <- as.formula(paste(colnames(cell_data)[i], "~ 1",sep=""))
  res[[i]] = form
  families[[i]] = poisson()
}
```

### Add noise to celldata

```{r}
#for (i in 1:n_cells){
#  cell_data[[i]] <- jitter(cell_data[[i]])
#  cell_data[[i]][cell_data[[i]] < 0] <- 0
#  cell_data[[i]] <- round(cell_data[[i]],0)
#}
#cell_data
```



### Model selection 

Try fit the model to different number of states

```{r}
set.seed(345)
model5 <- depmix(response = res, nstates = 5, data= cell_data, family = families)
fit5 <- fit(model5)
# 8 states
model8 <- depmix(response = res, nstates = 8, data= cell_data, family = families)
fit8 <- fit(model8)
```

```{r}
# 12 states
model9 <- depmix(response = res, nstates = 9, data= cell_data, family = families)
fit9 <- fit(model9)
```

Det konvergerer ikke:

```{r}
# states
# model12 <- depmix(response = res, nstates = 12, data= cell_data, family = families)
# fit12 <- fit(model12)

# model15 <- depmix(response = res, nstates = 12, data= cell_data, family = families)
# fit15 <- fit(model15)
```


```{r}
AIC(fit5)
AIC(fit8)
AIC(fit9)
#AIC(fit13)
#AIC(fit15)
```

### Choose the model with lowest AIC


```{r}
numstates = 9
```

```{r}
final_model <- depmix(response = res, nstates = numstates, data= cell_data, family = families)
final_fit <- fit(final_model)
```


```{r}
# Use the model with lowest AIC
states = posterior(final_fit)$state
idx_1 = which(states==1)
idx_state = c(list(idx_1))
ang_state = c(list(na.omit(angdata[idx_1])))
for (i in 2:numstates){
  cur_idx <- which(states == i)
  idx_state <- c(idx_state, list(cur_idx))
  ang_state <- c(ang_state, list(na.omit(angdata[cur_idx])))
}
```



```{r}
statevar <- rep(0,numstates)
for (i in 1:numstates){
  statevar[i] <-var(angdata[idx_state[[i]]], na.rm = TRUE)
}
print(statevar)
max_var_state <- which.max(statevar)
```

```{r}
#Avrege for of  
mean_ang_state = rep(0, numstates)
for (i in 1:numstates){
  mean_ang_state[i] <- mean(angdata[idx_state[[i]]], na.rm = TRUE)
}
print(mean_ang_state)
```


```{r}
unsorted_states <- c(1:numstates)
unsorted_states <- unsorted_states[!unsorted_states == max_var_state]
sorted_states <- max_var_state
for (i in 2:numstates){
  cur_min <- which.min(mean_ang_state[unsorted_states])
  sorted_states <- c(sorted_states, unsorted_states[cur_min])
  unsorted_states <- unsorted_states[-cur_min]
}
print(sorted_states)
```


### Plot the head direction for each states

```{r}
idx <- as.vector(sapply(ang_state, length))
ang = unlist(ang_state)
plot_states = c()
for (i in 1:length(idx)) {
  plot_states = c(plot_states, rep(i, idx[i]))
}
plot_data = data.frame(ang = ang, x=1:length(ang), plot_states=as.factor(plot_states))
```

```{r}
ggplot(data = plot_data) + geom_point(aes(x = x, y=ang, col = plot_states))
```

## Plot on a circle

```{r}
ts <- which(angdata != "NaN")
xs <- cos(angdata[ts])*ts
ys <- sin(angdata[ts])*ts


plot(xs,ys, col = states[ts]+1, pch = 20, ylab = "", yaxt = "n", xlab = "", xaxt = "n")
abline(v = 0, h =0)
```


```{r}
plot(angdata, main="", type="h", col = gray(.7))
text(angdata, col=states+1, labels=states, cex=.9)
```


## Plot the transition matrix

```{r}
transmatrix <- matrix(nrow = numstates,ncol = numstates)
for (i in 1:numstates){
  transmatrix[i,]<- final_fit@transition[[i]]@parameters$coefficients
}
transmatrix
heatmap(transmatrix[sorted_states,sorted_states], Colv = NA, Rowv = NA, revC = TRUE)
```

### Get the parameters

```{r}
u <- getpars(final_fit)
loglam = u[which(names(u)=="(Intercept)")]
lams = exp(unname(loglam))
```

### Bootstrapping


Code from the book

```{r}
pois.HMM.generate_sample = function(n,m,lambda,Mtrans,StatDist=NULL){
# n = data length, m = number of states, Mtrans = transition matrix, StatDist = stationary distn
 if(is.null(StatDist)) StatDist = solve(t(diag(m)-Mtrans +1),rep(1,m))
  mvect = 1:m
  state = numeric(n)
  state[1] = sample(mvect ,1, prob=StatDist)
  for (i in 2:n)
       state[i] = sample(mvect ,1,prob=Mtrans[state[i-1] ,])
  y = rpois(n,lambda=lambda[state ])
  list(y= y, state= state)   }
```

```{r}
set.seed(10101101)
nboot = 100
nobs = nrow(celldata)
para.star = matrix(NA, nrow=nboot, ncol = 6)
for (j in 1:nboot){
 x.star = pois.HMM.generate_sample(n=nobs, m=numstates, lambda=lams, Mtrans=transmatrix)$y
 model <- depmix(x.star ~1, nstates=numstates, data=data.frame(x.star),
family=poisson())
u = as.vector(getpars(fit(model, verbose=0)))
print(j)
}
```

